body{
    display: flex;
    height: 100vh;
    margin: 10px;
    font-family: sans-serif;
}

.container{
    margin: auto;
    width: 60%;
    display: grid;
    grid-gap: 4px;

    grid-template-rows: 100px 50px;
    grid-template-columns: repeat(3, 1fr);
}


.header{
    /* Avec "grid-column-start", on indique où commence l'espace qu'occupe l'élément. */
    grid-column-start: 1;

    /* Avec "grid-column-end", on indique jusqu'où va l'espace qu'occupe l'élément.
    */
    grid-column-end: 4;

    /* Ici, on indique donc que notre header devra occuper un espace dans le tableau qui part
    de la première colonne (inclue) à la quatrième colonne (exclue).
    En effet, faite le test, si on met "3" en "grid-column-end",
    l'espace qu'occupe le header va s'arrêter juste avant la troisième colonne.

    Encore une fois, il existe une manière raccourci d'écrire cela...
    Ainsi, "grid-column : 1 / 4" revient exactement au même que ce 
    que nous avons écrit ci-dessus ( le paramètre devant le "/" 
    étant le "start" et celui derrière le "/" étant le "end" ).


    Petite astuce :

    Ici, on sait que la grille est constituée de 3 colonnes,
    et que pour qu'un élément occupe toute la grille horizontalement,
    il faut lui dire qu'il l'occupe jusqu'à la quatrième colonne.

    Comment faire lorsque l'on ne connait pas d'avance le nombre 
    de colonne constituant la grille ?

    Il suffit d'utiliser un nombre négatif !
    En effet, en utilisant un nombre négatif, on lui indique de partir 
    de la gauche, donc de la fin, de la grille.

    Ainsi, en faisant "grid-column-end: -1", l'espace qu'occupe cet
    élément dans le tableau s'arrêtera à la dernière colonne (inclue).
    */
}

.footer{
    grid-column: 1 / span 3;
     /* Ici, même si le résultat est le même, 
     nous utilisons une technique légèrement différente... 
        - Pour le paramètre start, aucun changement;
        - Pour le paramètre de end par contre, le "span" permet de signifier 
          que l'espace occupé doit correspondre à 3 colonnes.
          Ainsi, au lieu de nous préoccuper de où doit s'arrêter
          l'espace qu'occupe notre élément, on s'intéresse
          directement au nombre de colonne qu'occupe notre élément.
    */
}

.menu{
    /* La même chose est bien évidemment valable pour les lignes. */
    grid-row-start: 2;
    grid-row-end: span 3;
}


.container > div{
    display: flex;
    justify-content: center;
    align-items: center;

    padding: 10px;
    font-size: 2em;
    color: white;
    opacity: 0.5;
}

/* Les lignes qui suivent servent à colorer différenmment les éléments */
.container > div:nth-child(2n){
    background-color: rgb(15, 129, 206);
}
.container > div:nth-child(2n + 1){
    background-color: rgb(151, 84, 240);
}
.container > div:first-child,
.container > div:last-child{
    background-color: rgb(218, 135, 28);
}
/* .container > div:nth-child(4n){
    background-color: rgb(30, 179, 0);
} */

.container > div:hover{
    opacity: 1;
}